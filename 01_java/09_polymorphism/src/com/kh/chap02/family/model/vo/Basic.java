package com.kh.chap02.family.model.vo;

public interface Basic {
	/*
	 * * 인터페이스
	 * 모든 필드가 상수필드이고, 모든 메소드가 추상메소드인 일종의 추상클래스
	 * 
	 * [표현법]
	 * public interface 인터페이스명 { 
	 * 		// 필드부 : 상수필드들만
	 * 		// 생성자부 : 어자피 추상클래스는 객체 생성이 불가하므로 생략
	 * 		// 메소드부 : 추상메소드들만
	 * 
	 * - 인터페이스에서 모든 필드는 무조건 상수 필드이다.
	 * - 인터페이스에서 모든 메소드는 무조건 추상 메소드이다.
	 * - 무조건 구현해야 하는게 있을때 인터페이스를 만들어서 상속하게 된다.
	 * - 추상클래스와 다르게 좀 더 강한 규칙성, 강제성을 제공하는게 인터페이스이다.
	 * 
	 * * 추상클래스와 인터페이스 비교
	 * 1. 공통점
		   - 객체 생성은 안되나, 다형성은 적용 가능
		   - 상속(구현)하는 클래스에 추상메소드를 오버라이딩 하도록 강제한다.
	 *  
	 *  2. 차이점
	 *     - 추상클래스는 클래스 내에 자유롭게 필드, 메소드를 생성 가능하고
	 *       추상메소드가 포함되었거나 포함되지 않더라도 abstract class로 생성하면 추상클래스로 정의됨
	 *       인터페이스는 인터페이스 내에 상수필드, 추상 메소드로만 구성되어야 한다.
		   - 인터페이스는 인터페이스 내에 상수필드, 추상메소드로만 구상되어야 한다.
		   - 존재하는 목적이 다르다.
		   	  추상 클래스 : 공통적인 코드를 모아두고 더 가져다가 기능을 "확장"시켜서 쓰겠다. (클래스명 extends 부모클래스명)
		   	  인터페이스 : 클래스의 기능 구현을 강제하기 위해서 가져다 쓰겠다. == 적어도 해당 메소드들은 다 가지고 있어야 한다.
		   	  															(클래스명 implements 인터페이스명)
		   	 => 즉, 구현을 강제함으로써 구현 객체들의 같은 동작을 보장할 수 있다.
		   	 
	 *  3. extends와 implements
	 *  	- 클래스간의 상속 관계일 경우   : 자식클래스명 extends 부모클래스명 (다중상속 불가)
	 *  	- 클래스와 인터페이스간의 구현관계일 경우 : 클래스명 implements 인터페이스명, 인터페이스명2, .. (다중구현 가능)
	 *  	- 인터페이스간의 상속관계 일 경우 : 자식인터페이스명 extends 부모인터페이스명, 부모인터페이스명 ( 다중상속 가능)
	 * }
	 */
	
	// 필드부 : 상수필드만 선언
	/* public static final */ int num = 10;
//	인터페이스에는 상수 필드만 정의할 수 있기 때문에 앞의 public static final은 생략 가능하다. (묵시적으로 쓰지 않음)
//	private int a; => 일반 필드 선언이 불가 
	
	
//	메소드부 : 추상메소드만 선언 가능
	/* public abstract */ void sleep();
	/* public abstract */ void eat();
//	인터페이스에는 추상메소드만 정의할 수 있기 때문에
//	앞의 public abstract는 생략 가능하다. (묵시적으로 쓰지 않음)
	
	
	
}
